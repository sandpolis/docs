{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sandpolis Official Documentation This site explains how to install , configure , and maintain Sandpolis. It also contains the official specification and a high-level programming reference useful to developers. The Basics You are likely already familiar with other remote-control applications that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install an agent on the computers you wish to manage and direct them to connect back to the main application running on your workstation. While relatively simple, there are some evident disadvantages to this approach: Your computer may not have a stable IP address or be reachable over the Internet You may want to quickly perform rudimentary tasks away from your computer such as from a mobile device This architecture does not scale as the number of agents increases Most modern administration systems now use a client-server-agent (CSA) architecture to address these problems. Rather than connecting agents directly to an application on your computer, a central server mediates interactions between you and your systems. Client <==> Server <==> Agent With CSA, clients and agents can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSA also comes with a few drawbacks: The server is another application to maintain Although easy to deploy, the Sandpolis server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server and harden its security. The server is a high value attack target The server is designed to be as resilient and secure as possible, but it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to it. To help mitigate the risks, all Sandpolis user accounts are required to use two-factor authentication and password rotation. Access alerts can also be configured to help unauthorized accesses get noticed as early as possible. The server can increase network latency Usually the network route between a user and their systems will be faster than the route through the server. This is especially true if a user is on the same lan as their systems. To improve latency and throughput, the server can automatically coordinate a direct connection between any two nodes for high-volume or time-sensitive messages like remote desktop, file transfers, etc. Real-time monitoring Sandpolis offers \"real-time\" monitoring and management when you need it, and efficient scalability when you're not looking. Extensibility via plugins","title":"Home"},{"location":"index.html#sandpolis-official-documentation","text":"This site explains how to install , configure , and maintain Sandpolis. It also contains the official specification and a high-level programming reference useful to developers.","title":"Sandpolis Official Documentation"},{"location":"index.html#the-basics","text":"You are likely already familiar with other remote-control applications that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install an agent on the computers you wish to manage and direct them to connect back to the main application running on your workstation. While relatively simple, there are some evident disadvantages to this approach: Your computer may not have a stable IP address or be reachable over the Internet You may want to quickly perform rudimentary tasks away from your computer such as from a mobile device This architecture does not scale as the number of agents increases Most modern administration systems now use a client-server-agent (CSA) architecture to address these problems. Rather than connecting agents directly to an application on your computer, a central server mediates interactions between you and your systems.","title":"The Basics"},{"location":"index.html#client-server-agent","text":"With CSA, clients and agents can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSA also comes with a few drawbacks:","title":"Client &lt;==&gt; Server &lt;==&gt; Agent"},{"location":"index.html#the-server-is-another-application-to-maintain","text":"Although easy to deploy, the Sandpolis server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server and harden its security.","title":"The server is another application to maintain"},{"location":"index.html#the-server-is-a-high-value-attack-target","text":"The server is designed to be as resilient and secure as possible, but it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to it. To help mitigate the risks, all Sandpolis user accounts are required to use two-factor authentication and password rotation. Access alerts can also be configured to help unauthorized accesses get noticed as early as possible.","title":"The server is a high value attack target"},{"location":"index.html#the-server-can-increase-network-latency","text":"Usually the network route between a user and their systems will be faster than the route through the server. This is especially true if a user is on the same lan as their systems. To improve latency and throughput, the server can automatically coordinate a direct connection between any two nodes for high-volume or time-sensitive messages like remote desktop, file transfers, etc.","title":"The server can increase network latency"},{"location":"index.html#real-time-monitoring","text":"Sandpolis offers \"real-time\" monitoring and management when you need it, and efficient scalability when you're not looking.","title":"Real-time monitoring"},{"location":"index.html#extensibility-via-plugins","text":"","title":"Extensibility via plugins"},{"location":"application/agent.html","text":"1 Agent Agent installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or client installation. 1.1 Filesystem Structure /base/agent.jar The agent executable, named according to the configuration. /base/agent.db The agent's only database, named according to the executable. /base/lib A directory for extracted agent-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 1.2 Additional Changes The agent-installer makes additional platform specific changes upon installation: 1.2.1 Windows 1.2.2 Linux 1.2.3 Mac OS 1.3 Upgrading There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent 1.3.1 Manual Upgrade A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost 1.3.2 Automated Upgrade If the agent is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates.","title":"Agent"},{"location":"application/agent.html#1-agent","text":"Agent installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or client installation.","title":"1 Agent"},{"location":"application/agent.html#11-filesystem-structure","text":"/base/agent.jar The agent executable, named according to the configuration. /base/agent.db The agent's only database, named according to the executable. /base/lib A directory for extracted agent-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"1.1 Filesystem Structure"},{"location":"application/agent.html#12-additional-changes","text":"The agent-installer makes additional platform specific changes upon installation:","title":"1.2 Additional Changes"},{"location":"application/agent.html#121-windows","text":"","title":"1.2.1 Windows"},{"location":"application/agent.html#122-linux","text":"","title":"1.2.2 Linux"},{"location":"application/agent.html#123-mac-os","text":"","title":"1.2.3 Mac OS"},{"location":"application/agent.html#13-upgrading","text":"There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent","title":"1.3 Upgrading"},{"location":"application/agent.html#131-manual-upgrade","text":"A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost","title":"1.3.1 Manual Upgrade"},{"location":"application/agent.html#132-automated-upgrade","text":"If the agent is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates.","title":"1.3.2 Automated Upgrade"},{"location":"application/client.html","text":"3 Client Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or server installation. 3.1 Filesystem Structure /base/client.jar The client executable. /base/client.ico An icon for the client /base/db A directory for client databases. Each server that the client connects to will have a corresponding database located here. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 3.2 Additional Changes The client-installer makes additional platform specific changes upon installation: 3.2.1 Windows 3.2.2 Linux 3.2.3 Mac OS Installer Flags Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Client"},{"location":"application/client.html#3-client","text":"Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or server installation.","title":"3 Client"},{"location":"application/client.html#31-filesystem-structure","text":"/base/client.jar The client executable. /base/client.ico An icon for the client /base/db A directory for client databases. Each server that the client connects to will have a corresponding database located here. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"3.1 Filesystem Structure"},{"location":"application/client.html#32-additional-changes","text":"The client-installer makes additional platform specific changes upon installation:","title":"3.2 Additional Changes"},{"location":"application/client.html#321-windows","text":"","title":"3.2.1 Windows"},{"location":"application/client.html#322-linux","text":"","title":"3.2.2 Linux"},{"location":"application/client.html#323-mac-os","text":"","title":"3.2.3 Mac OS"},{"location":"application/client.html#installer-flags","text":"Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Installer Flags"},{"location":"application/network.html","text":"Sandpolis Protocol Sandpolis uses a custom binary protocol for all network communications that runs on TCP port 8768 by default. The Sandpolis protocol uses protocol buffers extensively which allows it to be fast, flexible, and language independent. Most communication happens over TCP connections among instances and the server, but Sandpolis can also coordinate direct TCP or UDP \"sessions\" between any two instances that need to transfer real-time data. Streams Many Sandpolis operations require real-time data for a short-lived or long-lived session. This is accomplished with the concept of a stream. All streams have a \"source\" and a \"sink\" and can exist between any two instances (a stream where the source and sink reside on the same instance is called a local stream ). The source's purpose is to produce stream events at whatever frequency is appropriate for the use-case and the sink's purpose is to consume those stream events. Multicasting Stream sources can push events to more than one sink simultaneously. This is called stream multicasting and saves bandwidth when multiple users request the same resource at the same time.","title":"Networking"},{"location":"application/network.html#sandpolis-protocol","text":"Sandpolis uses a custom binary protocol for all network communications that runs on TCP port 8768 by default. The Sandpolis protocol uses protocol buffers extensively which allows it to be fast, flexible, and language independent. Most communication happens over TCP connections among instances and the server, but Sandpolis can also coordinate direct TCP or UDP \"sessions\" between any two instances that need to transfer real-time data.","title":"Sandpolis Protocol"},{"location":"application/network.html#streams","text":"Many Sandpolis operations require real-time data for a short-lived or long-lived session. This is accomplished with the concept of a stream. All streams have a \"source\" and a \"sink\" and can exist between any two instances (a stream where the source and sink reside on the same instance is called a local stream ). The source's purpose is to produce stream events at whatever frequency is appropriate for the use-case and the sink's purpose is to consume those stream events.","title":"Streams"},{"location":"application/network.html#multicasting","text":"Stream sources can push events to more than one sink simultaneously. This is called stream multicasting and saves bandwidth when multiple users request the same resource at the same time.","title":"Multicasting"},{"location":"application/server.html","text":"Server Port The official port for the Sandpolis server is 8768 . Geolocation Services Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com Permissions Since multiple clients can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin client is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server. Permissions list Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client Authentication Groups Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network. Generators Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system. Installation Artifacts At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system. Installers An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended. Advantages Simple Does not require Internet access during installation Disadvantages File size is large File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Downloaders Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server. Advantages Smaller file size Disadvantages Requires Internet access during installation File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Tokens A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system. Advantages No files are transferred Disadvantages More user interaction is required Examples Barcodes for use on Android, IOS, etc... Generators All installation artifacts are first generated on the server using a generator and then transferred to the requesting client (or client in the case of an automated upgrade). Generator Queue Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped. Generator Configs A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the client from the graphical interface. 2 Server Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or client installation. 2.1 Filesystem Structure /base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory. 2.2 Additional Changes The server-installer makes additional platform specific changes upon installation: 2.2.1 Windows TODO: Research services 2.2.2 Linux 2.2.2.1 Systemd Management via systemd is supported. 2.2.3 Mac OS","title":"Server"},{"location":"application/server.html#server-port","text":"The official port for the Sandpolis server is 8768 .","title":"Server Port"},{"location":"application/server.html#geolocation-services","text":"Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com","title":"Geolocation Services"},{"location":"application/server.html#permissions","text":"Since multiple clients can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin client is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server.","title":"Permissions"},{"location":"application/server.html#permissions-list","text":"Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client","title":"Permissions list"},{"location":"application/server.html#authentication-groups","text":"Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network.","title":"Authentication Groups"},{"location":"application/server.html#generators","text":"Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system.","title":"Generators"},{"location":"application/server.html#installation-artifacts","text":"At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system.","title":"Installation Artifacts"},{"location":"application/server.html#installers","text":"An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended.","title":"Installers"},{"location":"application/server.html#advantages","text":"Simple Does not require Internet access during installation","title":"Advantages"},{"location":"application/server.html#disadvantages","text":"File size is large File transfer may be inconvenient","title":"Disadvantages"},{"location":"application/server.html#examples","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"application/server.html#downloaders","text":"Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server.","title":"Downloaders"},{"location":"application/server.html#advantages_1","text":"Smaller file size","title":"Advantages"},{"location":"application/server.html#disadvantages_1","text":"Requires Internet access during installation File transfer may be inconvenient","title":"Disadvantages"},{"location":"application/server.html#examples_1","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"application/server.html#tokens","text":"A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system.","title":"Tokens"},{"location":"application/server.html#advantages_2","text":"No files are transferred","title":"Advantages"},{"location":"application/server.html#disadvantages_2","text":"More user interaction is required","title":"Disadvantages"},{"location":"application/server.html#examples_2","text":"Barcodes for use on Android, IOS, etc...","title":"Examples"},{"location":"application/server.html#generators_1","text":"All installation artifacts are first generated on the server using a generator and then transferred to the requesting client (or client in the case of an automated upgrade).","title":"Generators"},{"location":"application/server.html#generator-queue","text":"Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped.","title":"Generator Queue"},{"location":"application/server.html#generator-configs","text":"A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the client from the graphical interface.","title":"Generator Configs"},{"location":"application/server.html#2-server","text":"Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or client installation.","title":"2 Server"},{"location":"application/server.html#21-filesystem-structure","text":"/base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory.","title":"2.1 Filesystem Structure"},{"location":"application/server.html#22-additional-changes","text":"The server-installer makes additional platform specific changes upon installation:","title":"2.2 Additional Changes"},{"location":"application/server.html#221-windows","text":"TODO: Research services","title":"2.2.1 Windows"},{"location":"application/server.html#222-linux","text":"","title":"2.2.2 Linux"},{"location":"application/server.html#2221-systemd","text":"Management via systemd is supported.","title":"2.2.2.1 Systemd"},{"location":"application/server.html#223-mac-os","text":"","title":"2.2.3 Mac OS"},{"location":"specification/agent.html","text":"Agent Instance At a general level, agents are responsible for carrying out tasks for remote users. They can connect over the network to any other type of instance. At minimum, agents must be associated with one server. Agent Configuration The agent's configuration is represented in standard Java properties format and is named agent.properties . The configuration may be embedded in the agent's executable or configured by the user at runtime. Property Description instance.version The instance's version string build.platform The build platform's name build.timestamp UTC epoch timestamp server.address A CSV of IP addresses or domain names including port information server.timeout The server connection timeout in milliseconds server.strict_certs The agent will refuse to connect to a server that presents an invalid certificate agent.polling.interval The connection poll interval in milliseconds Connection Modes There are two connection modes that have an impact on performance and latency. Continuous In continuous mode, the agent maintains its primary connection at all times. If the connection is lost, the agent will periodically attempt to reestablish the connection using the same parameters it used to establish the initial connection. The connection mode can be changed on-the-fly by a user or scheduled to change automatically according to the time and day. Polling In polling mode, the agent intentionally closes the primary connection unless there exists an active stream. On a configurable schedule, the agent reconnects to a server, flushes any cached data, and checks for any new work items. After executing all available work items, the primary connection is closed again. The agent may attempt a spontaneous connection outside of the regular schedule if an internal agent process triggers it. Plugins Agents can optionally support plugins to enhance functionality beyond the standard feature set. Upon initial connection, the agent provides a list of plugin versions that it has loaded. The server responds with a list of plugin archives that the agent should install. Standard Feature Set The standard feature set is the minimum amount of functionality an agent implementation must provide. AgentMetadata Upgrades There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent Manual Upgrade A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost Automated Upgrade If the agent is connected to a server, it can be upgraded remotely. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates. Container Resident","title":"Agent"},{"location":"specification/agent.html#agent-instance","text":"At a general level, agents are responsible for carrying out tasks for remote users. They can connect over the network to any other type of instance. At minimum, agents must be associated with one server.","title":"Agent Instance"},{"location":"specification/agent.html#agent-configuration","text":"The agent's configuration is represented in standard Java properties format and is named agent.properties . The configuration may be embedded in the agent's executable or configured by the user at runtime. Property Description instance.version The instance's version string build.platform The build platform's name build.timestamp UTC epoch timestamp server.address A CSV of IP addresses or domain names including port information server.timeout The server connection timeout in milliseconds server.strict_certs The agent will refuse to connect to a server that presents an invalid certificate agent.polling.interval The connection poll interval in milliseconds","title":"Agent Configuration"},{"location":"specification/agent.html#connection-modes","text":"There are two connection modes that have an impact on performance and latency.","title":"Connection Modes"},{"location":"specification/agent.html#continuous","text":"In continuous mode, the agent maintains its primary connection at all times. If the connection is lost, the agent will periodically attempt to reestablish the connection using the same parameters it used to establish the initial connection. The connection mode can be changed on-the-fly by a user or scheduled to change automatically according to the time and day.","title":"Continuous"},{"location":"specification/agent.html#polling","text":"In polling mode, the agent intentionally closes the primary connection unless there exists an active stream. On a configurable schedule, the agent reconnects to a server, flushes any cached data, and checks for any new work items. After executing all available work items, the primary connection is closed again. The agent may attempt a spontaneous connection outside of the regular schedule if an internal agent process triggers it.","title":"Polling"},{"location":"specification/agent.html#plugins","text":"Agents can optionally support plugins to enhance functionality beyond the standard feature set. Upon initial connection, the agent provides a list of plugin versions that it has loaded. The server responds with a list of plugin archives that the agent should install.","title":"Plugins"},{"location":"specification/agent.html#standard-feature-set","text":"The standard feature set is the minimum amount of functionality an agent implementation must provide.","title":"Standard Feature Set"},{"location":"specification/agent.html#agentmetadata","text":"","title":"AgentMetadata"},{"location":"specification/agent.html#upgrades","text":"There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent","title":"Upgrades"},{"location":"specification/agent.html#manual-upgrade","text":"A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost","title":"Manual Upgrade"},{"location":"specification/agent.html#automated-upgrade","text":"If the agent is connected to a server, it can be upgraded remotely. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates.","title":"Automated Upgrade"},{"location":"specification/agent.html#container-resident","text":"","title":"Container Resident"},{"location":"specification/clientserver.html","text":"Client/Server Messages Server RQ_ServerBanner // Request the server's banner. // // Source: Client // Destination: Server // Request: RS_ServerBanner RS_ServerBanner // Response with the server's banner. // // Source: Server // Destination: Client // Request: RQ_ServerBanner Message Format Field Type Requirements Description maintenance bool Indicates that only superusers will be allowed to login version string 5 - 32 characters The server's version string message string 0 - 128 characters The banner text message image bytes 0 - 1 MiB PNG format The banner image Login RQ_Logout // Attempt to logout. // // Source: Client // Destination: Server // Response: Outcome RQ_Login // Attempt to login. // // Source: Client // Destination: Server // Response: Outcome Message Format Field Type Requirements Description username string 5 - 32 characters The username password string 5 - 32 characters An unsalted SHA512 hash of the password token int32 A TOTP token","title":"Client/Server"},{"location":"specification/clientserver.html#clientserver-messages","text":"","title":"Client/Server Messages"},{"location":"specification/clientserver.html#server","text":"","title":"Server"},{"location":"specification/clientserver.html#rq_serverbanner","text":"// Request the server's banner. // // Source: Client // Destination: Server // Request: RS_ServerBanner","title":"RQ_ServerBanner"},{"location":"specification/clientserver.html#rs_serverbanner","text":"// Response with the server's banner. // // Source: Server // Destination: Client // Request: RQ_ServerBanner","title":"RS_ServerBanner"},{"location":"specification/clientserver.html#message-format","text":"Field Type Requirements Description maintenance bool Indicates that only superusers will be allowed to login version string 5 - 32 characters The server's version string message string 0 - 128 characters The banner text message image bytes 0 - 1 MiB PNG format The banner image","title":"Message Format"},{"location":"specification/clientserver.html#login","text":"","title":"Login"},{"location":"specification/clientserver.html#rq_logout","text":"// Attempt to logout. // // Source: Client // Destination: Server // Response: Outcome","title":"RQ_Logout"},{"location":"specification/clientserver.html#rq_login","text":"// Attempt to login. // // Source: Client // Destination: Server // Response: Outcome","title":"RQ_Login"},{"location":"specification/clientserver.html#message-format_1","text":"Field Type Requirements Description username string 5 - 32 characters The username password string 5 - 32 characters An unsalted SHA512 hash of the password token int32 A TOTP token","title":"Message Format"},{"location":"specification/instance.html","text":"Instance The following sections apply to all Sandpolis instances. Data Model There are three layers in the Sandpolis data model. Of which, client implementations are required to support at least two (ST and OID layers). The ST Layer The State Tree layer is the lowest layer and is concerned with storage and persistence. Every instance maintains a global tree called the \"ST Tree\". The tree is seldomly manipulated directly. Instead, higher layers make changes to the ST Tree on behalf of consumers. The ST tree is composed of two components: Attribute s and Document s. Attributes Attributes contain data of a specific type and meaning. All data in the ST tree is stored in attributes. Retention The history of an attribute can optionally be recorded with tracked attributes . AttributeChangedEvent Documents Documents are a set of attributes and sub-documents. DocumentAddedEvent Indicates that a document has been added to the tree. No futher events will be fired for all children of the added document as a direct result of the addition. DocumentRemovedEvent Indicates that a document has been removed from the tree. Entanglement A concept that exists at the ST layer is entanglement : ST trees that reside on remote instances can synchronize their state. The relation can be bidirectional or unidirectional and last as long as necessary. All changes to the source of an entanglement pair will be propagated to the destination in real-time. Snapshots and Merging The VST Layer The OID Layer Every node in a ST Tree is uniquely identified by an OID. OIDs are sequences of / separated strings that describe how to reach the corresponding node from the root node. OIDs also have a string namespace identifier that identifies the plugin or module to which the OID belongs.","title":"Instance"},{"location":"specification/instance.html#instance","text":"The following sections apply to all Sandpolis instances.","title":"Instance"},{"location":"specification/instance.html#data-model","text":"There are three layers in the Sandpolis data model. Of which, client implementations are required to support at least two (ST and OID layers).","title":"Data Model"},{"location":"specification/instance.html#the-st-layer","text":"The State Tree layer is the lowest layer and is concerned with storage and persistence. Every instance maintains a global tree called the \"ST Tree\". The tree is seldomly manipulated directly. Instead, higher layers make changes to the ST Tree on behalf of consumers. The ST tree is composed of two components: Attribute s and Document s.","title":"The ST Layer"},{"location":"specification/instance.html#attributes","text":"Attributes contain data of a specific type and meaning. All data in the ST tree is stored in attributes.","title":"Attributes"},{"location":"specification/instance.html#retention","text":"The history of an attribute can optionally be recorded with tracked attributes .","title":"Retention"},{"location":"specification/instance.html#attributechangedevent","text":"","title":"AttributeChangedEvent"},{"location":"specification/instance.html#documents","text":"Documents are a set of attributes and sub-documents.","title":"Documents"},{"location":"specification/instance.html#documentaddedevent","text":"Indicates that a document has been added to the tree. No futher events will be fired for all children of the added document as a direct result of the addition.","title":"DocumentAddedEvent"},{"location":"specification/instance.html#documentremovedevent","text":"Indicates that a document has been removed from the tree.","title":"DocumentRemovedEvent"},{"location":"specification/instance.html#entanglement","text":"A concept that exists at the ST layer is entanglement : ST trees that reside on remote instances can synchronize their state. The relation can be bidirectional or unidirectional and last as long as necessary. All changes to the source of an entanglement pair will be propagated to the destination in real-time.","title":"Entanglement"},{"location":"specification/instance.html#snapshots-and-merging","text":"","title":"Snapshots and Merging"},{"location":"specification/instance.html#the-vst-layer","text":"","title":"The VST Layer"},{"location":"specification/instance.html#the-oid-layer","text":"Every node in a ST Tree is uniquely identified by an OID. OIDs are sequences of / separated strings that describe how to reach the corresponding node from the root node. OIDs also have a string namespace identifier that identifies the plugin or module to which the OID belongs.","title":"The OID Layer"},{"location":"specification/server.html","text":"Server Instance Every Sandpolis network must include one server instance at minimum. Servers are responsible for coordinating interactions among instances and persisting data. Listening port The Sandpolis server listens on TCP port 8768 by default, but can be configured to listen on a different port or multiple ports concurrently. Geolocation Services Sandpolis is able to get its location information from several sources. To select a location service, the following configuration options are recognized: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com Database Property Default Description s7s.storage.provider ephemeral The database storage provider s7s.storage.mongodb.host The address of the mongodb host s7s.storage.mongodb.username The mongodb user's username s7s.storage.mongodb.password The mongodb user's password First Start If the server starts with ephemeral storage or an empty database, the server enters \"first start\" mode. This mode has the following implications: Default admin password The admin password will be randomized and printed in the server log. All clients are required to force users to change the admin password and setup multi-factor authentication before proceeding after the first login. Connection Blocking The server will refuse connections from IP addresses on a configurable blocklist or those that trigger the global rate-limiting policy. IP address on a configurable whitelist are exempt from rate-limiting. Permissions All user accounts are subject to a set of permissions controlling what server operations are authorized. The inital admin user has complete and irrevocable permissions. By default, additional user accounts are created without permissions and consequently are allowed to do almost nothing. Permissions list Permission Description server.generate Rights to use the generator server.users.list Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.net.view Right to open the network control panel server.listener.create Right to create a new listener on the server server.listener.list Right to view all listeners on the server server.group.create Right to create a new authentication group on the server server.group.list Right to view all authentication groups on the server agent.system.power Right to shutdown, reboot, etc the agent Agent Groups Agent groups are sets of agents that share one or more authentication schemes. Every group has exactly one owner and zero or more (user) members. Password Authentication Scheme After establishing a connection, agents may present an unsalted SHA512 hash of a password entered by the user to the server. The server compares the password to each agent group until it finds a match. If a match is found, the agent is becomes authenticated to the matching agent group. Otherwise, the connection is closed if more than 5 attempts were made on that connection. Since a user must type the password manually, the server will attempt to configure the certificate authentication scheme for all subsequent connections. Token Authentication Scheme The agent may provide an 8 character alphanumeric time-based token periodically generated by the server from an agent group's secret key. Since a user must type the token in manually, the server will attempt to configure the certificate authentication scheme for all subsequent connections. Certificate Authentication Scheme The agent may provide an X509 \"client\" certificate signed by an agent group's secret key during the initial connection attempt. If the agent certificate was found to be valid, the connection is automatically authenticated without any additional message exchanges. Agent Certificate Expiration The default lifetime for an agent certificate is six months. The following section implies an agent must connect to a server at least once every 1.5 months otherwise it loses its ability to authenticate. Agent Certificate Renewal Once 75% of the lifetime of an agent certificate elapses, the server attempts to issue a new certificate and installs it on the agent. Agent Generators A Generator is a routine which produces some installation artifact according to the parameters set out in an authentication group. The installation artifact can then be used to install an agent on a remote system. Standard agent (com.sandpolis.agent.vanilla) Native agent (com.sandpolis.agent.micro) Minimal agent (com.sandpolis.agent.nano) Installers On execution, installers set up the agent base directory according to its configuration and executes the agent. If the target directory already contains an installation, the old installation is entirely overwritten. Installer Configuration Installers have an embedded configuration file called install.properties that describes how the installation process should proceed. Property Description agent.type The agent type (vanilla, micro, or nano) agent.path The filesystem path agent.auth.scheme The name of the authentication scheme to use (password or certificate) install.recover Whether the installation should attempt to continue if errors occur Packager A packager is responsible for creating an agent installer binary according to the parameters set out in an authentication group. Deployer A deployer is responsible for deploying generated agent installers to remote systems automatically. SSH Deployer The SSH deployer first determines the remote system type and invokes an appropriate packager to generate an installer. The installer is then transferred to the remote host and executed.","title":"Server"},{"location":"specification/server.html#server-instance","text":"Every Sandpolis network must include one server instance at minimum. Servers are responsible for coordinating interactions among instances and persisting data.","title":"Server Instance"},{"location":"specification/server.html#listening-port","text":"The Sandpolis server listens on TCP port 8768 by default, but can be configured to listen on a different port or multiple ports concurrently.","title":"Listening port"},{"location":"specification/server.html#geolocation-services","text":"Sandpolis is able to get its location information from several sources. To select a location service, the following configuration options are recognized: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com","title":"Geolocation Services"},{"location":"specification/server.html#database","text":"Property Default Description s7s.storage.provider ephemeral The database storage provider s7s.storage.mongodb.host The address of the mongodb host s7s.storage.mongodb.username The mongodb user's username s7s.storage.mongodb.password The mongodb user's password","title":"Database"},{"location":"specification/server.html#first-start","text":"If the server starts with ephemeral storage or an empty database, the server enters \"first start\" mode. This mode has the following implications:","title":"First Start"},{"location":"specification/server.html#default-admin-password","text":"The admin password will be randomized and printed in the server log. All clients are required to force users to change the admin password and setup multi-factor authentication before proceeding after the first login.","title":"Default admin password"},{"location":"specification/server.html#connection-blocking","text":"The server will refuse connections from IP addresses on a configurable blocklist or those that trigger the global rate-limiting policy. IP address on a configurable whitelist are exempt from rate-limiting.","title":"Connection Blocking"},{"location":"specification/server.html#permissions","text":"All user accounts are subject to a set of permissions controlling what server operations are authorized. The inital admin user has complete and irrevocable permissions. By default, additional user accounts are created without permissions and consequently are allowed to do almost nothing.","title":"Permissions"},{"location":"specification/server.html#permissions-list","text":"Permission Description server.generate Rights to use the generator server.users.list Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.net.view Right to open the network control panel server.listener.create Right to create a new listener on the server server.listener.list Right to view all listeners on the server server.group.create Right to create a new authentication group on the server server.group.list Right to view all authentication groups on the server agent.system.power Right to shutdown, reboot, etc the agent","title":"Permissions list"},{"location":"specification/server.html#agent-groups","text":"Agent groups are sets of agents that share one or more authentication schemes. Every group has exactly one owner and zero or more (user) members.","title":"Agent Groups"},{"location":"specification/server.html#password-authentication-scheme","text":"After establishing a connection, agents may present an unsalted SHA512 hash of a password entered by the user to the server. The server compares the password to each agent group until it finds a match. If a match is found, the agent is becomes authenticated to the matching agent group. Otherwise, the connection is closed if more than 5 attempts were made on that connection. Since a user must type the password manually, the server will attempt to configure the certificate authentication scheme for all subsequent connections.","title":"Password Authentication Scheme"},{"location":"specification/server.html#token-authentication-scheme","text":"The agent may provide an 8 character alphanumeric time-based token periodically generated by the server from an agent group's secret key. Since a user must type the token in manually, the server will attempt to configure the certificate authentication scheme for all subsequent connections.","title":"Token Authentication Scheme"},{"location":"specification/server.html#certificate-authentication-scheme","text":"The agent may provide an X509 \"client\" certificate signed by an agent group's secret key during the initial connection attempt. If the agent certificate was found to be valid, the connection is automatically authenticated without any additional message exchanges.","title":"Certificate Authentication Scheme"},{"location":"specification/server.html#agent-certificate-expiration","text":"The default lifetime for an agent certificate is six months. The following section implies an agent must connect to a server at least once every 1.5 months otherwise it loses its ability to authenticate.","title":"Agent Certificate Expiration"},{"location":"specification/server.html#agent-certificate-renewal","text":"Once 75% of the lifetime of an agent certificate elapses, the server attempts to issue a new certificate and installs it on the agent.","title":"Agent Certificate Renewal"},{"location":"specification/server.html#agent-generators","text":"A Generator is a routine which produces some installation artifact according to the parameters set out in an authentication group. The installation artifact can then be used to install an agent on a remote system. Standard agent (com.sandpolis.agent.vanilla) Native agent (com.sandpolis.agent.micro) Minimal agent (com.sandpolis.agent.nano)","title":"Agent Generators"},{"location":"specification/server.html#installers","text":"On execution, installers set up the agent base directory according to its configuration and executes the agent. If the target directory already contains an installation, the old installation is entirely overwritten.","title":"Installers"},{"location":"specification/server.html#installer-configuration","text":"Installers have an embedded configuration file called install.properties that describes how the installation process should proceed. Property Description agent.type The agent type (vanilla, micro, or nano) agent.path The filesystem path agent.auth.scheme The name of the authentication scheme to use (password or certificate) install.recover Whether the installation should attempt to continue if errors occur","title":"Installer Configuration"},{"location":"specification/server.html#packager","text":"A packager is responsible for creating an agent installer binary according to the parameters set out in an authentication group.","title":"Packager"},{"location":"specification/server.html#deployer","text":"A deployer is responsible for deploying generated agent installers to remote systems automatically.","title":"Deployer"},{"location":"specification/server.html#ssh-deployer","text":"The SSH deployer first determines the remote system type and invokes an appropriate packager to generate an installer. The installer is then transferred to the remote host and executed.","title":"SSH Deployer"},{"location":"specification/serveragent.html","text":"Server/Agent Messages Agent Authentication Messages RQ_NoAuth // Attempt to authenticate as an agent without providing anything. // // Source: Agent // Destination: Server // Response: Outcome RQ_PasswordAuth // Attempt to authenticate as an agent using a simple password. // // Source: Agent // Destination: Server // Response: Outcome Message Format Field Type Requirements Description password string 8 - 64 characters The password text RQ_CertAuth // Attempt to authenticate as an agent using a \"client\" certificate. // // Source: Agent // Destination: Server // Response: Outcome General Messages RQ_AgentMetadata // Request agent metadata. // // Source: Server // Destination: Agent // Response: RS_AgentMetadata RS_AgentMetadata // Response with agent metadata. // // Source: Agent // Destination: Server // Request: RQ_AgentMetadata Message Format Field Type Requirements Description hostname string 0 - 64 characters The agent's network hostname os OsType The agent's OS family arch string The agent's CPU architecture","title":"Server/Agent"},{"location":"specification/serveragent.html#serveragent-messages","text":"","title":"Server/Agent Messages"},{"location":"specification/serveragent.html#agent-authentication-messages","text":"","title":"Agent Authentication Messages"},{"location":"specification/serveragent.html#rq_noauth","text":"// Attempt to authenticate as an agent without providing anything. // // Source: Agent // Destination: Server // Response: Outcome","title":"RQ_NoAuth"},{"location":"specification/serveragent.html#rq_passwordauth","text":"// Attempt to authenticate as an agent using a simple password. // // Source: Agent // Destination: Server // Response: Outcome","title":"RQ_PasswordAuth"},{"location":"specification/serveragent.html#message-format","text":"Field Type Requirements Description password string 8 - 64 characters The password text","title":"Message Format"},{"location":"specification/serveragent.html#rq_certauth","text":"// Attempt to authenticate as an agent using a \"client\" certificate. // // Source: Agent // Destination: Server // Response: Outcome","title":"RQ_CertAuth"},{"location":"specification/serveragent.html#general-messages","text":"","title":"General Messages"},{"location":"specification/serveragent.html#rq_agentmetadata","text":"// Request agent metadata. // // Source: Server // Destination: Agent // Response: RS_AgentMetadata","title":"RQ_AgentMetadata"},{"location":"specification/serveragent.html#rs_agentmetadata","text":"// Response with agent metadata. // // Source: Agent // Destination: Server // Request: RQ_AgentMetadata","title":"RS_AgentMetadata"},{"location":"specification/serveragent.html#message-format_1","text":"Field Type Requirements Description hostname string 0 - 64 characters The agent's network hostname os OsType The agent's OS family arch string The agent's CPU architecture","title":"Message Format"},{"location":"specification/plugins/device.html","text":"Device Plugin The device plugin extends management functionality out to agent-less devices. Subagents Subagents are devices that do not have a Sandpolis agent software installed, but are instead managed via a third-party protocol such as SSH, HTTP, or SNMP from an instance called the gateway . The gateway instance for a subagent may be an independent agent or a server. Communicators A subagent communicates to its gateway instance over one of the following well-known protocols. Since subagents must accept incoming connections, the gateway instance usually must reside on the same network segment. SSH Property Description ssh.username The SSH username HTTP SNMP Property Description snmp.version The SNMP version","title":"Device Plugin"},{"location":"specification/plugins/device.html#device-plugin","text":"The device plugin extends management functionality out to agent-less devices.","title":"Device Plugin"},{"location":"specification/plugins/device.html#subagents","text":"Subagents are devices that do not have a Sandpolis agent software installed, but are instead managed via a third-party protocol such as SSH, HTTP, or SNMP from an instance called the gateway . The gateway instance for a subagent may be an independent agent or a server.","title":"Subagents"},{"location":"specification/plugins/device.html#communicators","text":"A subagent communicates to its gateway instance over one of the following well-known protocols. Since subagents must accept incoming connections, the gateway instance usually must reside on the same network segment.","title":"Communicators"},{"location":"specification/plugins/device.html#ssh","text":"Property Description ssh.username The SSH username","title":"SSH"},{"location":"specification/plugins/device.html#http","text":"","title":"HTTP"},{"location":"specification/plugins/device.html#snmp","text":"Property Description snmp.version The SNMP version","title":"SNMP"},{"location":"specification/plugins/filesystem.html","text":"Filesystem Plugin The filesystem plugin exposes agent and client filesystems to Sandpolis. Mounting Remote filesystems may be mounted on clients or agents with FUSE. Once established, the mount is permanent until explicitly closed by the user. By default, the entire filesystem is mounted, but can be configured to only expose a particular subtree. Agent mount An agent's filesystem may be mounted to a mountpoint on another agent or on a client's machine. Client mount A client's filesystem may be mounted to a mountpoint on an agent's machine. Permissions list Permission Description agent.fs.mount Rights to mount an agent's filesystem agent.fs.read Rights to read an agent's filesystem agent.fs.write Rights to write an agent's filesystem client.fs.mount Rights to mount the current client's filesystem client.fs.read Rights to read the current client's filesystem client.fs.write Rights to write the current client's filesystem","title":"Filesystem Plugin"},{"location":"specification/plugins/filesystem.html#filesystem-plugin","text":"The filesystem plugin exposes agent and client filesystems to Sandpolis.","title":"Filesystem Plugin"},{"location":"specification/plugins/filesystem.html#mounting","text":"Remote filesystems may be mounted on clients or agents with FUSE. Once established, the mount is permanent until explicitly closed by the user. By default, the entire filesystem is mounted, but can be configured to only expose a particular subtree.","title":"Mounting"},{"location":"specification/plugins/filesystem.html#agent-mount","text":"An agent's filesystem may be mounted to a mountpoint on another agent or on a client's machine.","title":"Agent mount"},{"location":"specification/plugins/filesystem.html#client-mount","text":"A client's filesystem may be mounted to a mountpoint on an agent's machine.","title":"Client mount"},{"location":"specification/plugins/filesystem.html#permissions-list","text":"Permission Description agent.fs.mount Rights to mount an agent's filesystem agent.fs.read Rights to read an agent's filesystem agent.fs.write Rights to write an agent's filesystem client.fs.mount Rights to mount the current client's filesystem client.fs.read Rights to read the current client's filesystem client.fs.write Rights to write the current client's filesystem","title":"Permissions list"},{"location":"specification/plugins/snapshot.html","text":"Snapshot Plugin The snapshot plugin gives agents the ability to take and apply snapshots, even on filesystems that don't natively support snapshots. Block-based snapshots The target device is divided into blocks of variable size (power of 2 only). Each block has a corresponding block hash which is the murmur3 128-bit hash of its content. File-based snapshots Server The server is responsible for storing snapshot data and uploading/downloading it to/from agents. Snapshot format Snapshot contents are stored in QEMU qcow2 files on the server. This format is mature and supports useful features like compression and encryption. Agent Bootagent A bootagent is responsible for reading/writing the actual data to/from the agent's disks. Residency The bootagent runs in a minimized Alpine Linux environment. Create Snapshot If there exist no previous snapshots, the bootagent first determines the appropriate block size for the disk. The agent may take into account the size of the disk or the erase-block size of an SSD, but the block size must be a power of two. If allowed, the agent will wipe the disk's free space before continuing. This can significantly decrease the size of the resulting snapshot because empty blocks are omitted. If there exists a previous snapshot for the disk, the agent receives a stream of block hashes. A single worker thread reads blocks from the disk and compares their hashes against the block hashes retrieved from the server. If the hashes do not match, the block is passed into a send queue to be egressed to the server. Apply Snapshot If there exists a previous snapshot for the disk, the agent initiates a stream of block hashes. A single worker thread reads blocks from the disk and passes their hashes into a send queue to be egressed to the server. Simultaneously, the agent receives a stream of block data which are placed into a write queue to be written to the device. Snapshot Messages EV_SnapshotDataBlock // Contains snapshot data. // // Source: Server, Agent // Destination: Server, Agent Field Type Requirements Description offset int64 The block's offset data bytes The block's contents compressed with zlib EV_SnapshotHashBlock // Contains a list of contiguous snapshot hashes. // // Source: Server, Agent // Destination: Server, Agent Field Type Requirements Description offset int64 The offset of the block that the first hash corresponds hash repeated bytes A list of block hashes Permissions list Permission Description agent.snapshot.create Rights create new snapshots of agent disks agent.snapshot.apply Rights apply existing snapshots to agent disks server.snapshot.list Rights to list existing snapshots stored by the server Configuration Property Default Description s7s.snapshot.storage.provider filesystem The storage provider to use s7s.snapshot.storage.filesystem.path The filesystem path","title":"Snapshot Plugin"},{"location":"specification/plugins/snapshot.html#snapshot-plugin","text":"The snapshot plugin gives agents the ability to take and apply snapshots, even on filesystems that don't natively support snapshots.","title":"Snapshot Plugin"},{"location":"specification/plugins/snapshot.html#block-based-snapshots","text":"The target device is divided into blocks of variable size (power of 2 only). Each block has a corresponding block hash which is the murmur3 128-bit hash of its content.","title":"Block-based snapshots"},{"location":"specification/plugins/snapshot.html#file-based-snapshots","text":"","title":"File-based snapshots"},{"location":"specification/plugins/snapshot.html#server","text":"The server is responsible for storing snapshot data and uploading/downloading it to/from agents.","title":"Server"},{"location":"specification/plugins/snapshot.html#snapshot-format","text":"Snapshot contents are stored in QEMU qcow2 files on the server. This format is mature and supports useful features like compression and encryption.","title":"Snapshot format"},{"location":"specification/plugins/snapshot.html#agent","text":"","title":"Agent"},{"location":"specification/plugins/snapshot.html#bootagent","text":"A bootagent is responsible for reading/writing the actual data to/from the agent's disks.","title":"Bootagent"},{"location":"specification/plugins/snapshot.html#residency","text":"The bootagent runs in a minimized Alpine Linux environment.","title":"Residency"},{"location":"specification/plugins/snapshot.html#create-snapshot","text":"If there exist no previous snapshots, the bootagent first determines the appropriate block size for the disk. The agent may take into account the size of the disk or the erase-block size of an SSD, but the block size must be a power of two. If allowed, the agent will wipe the disk's free space before continuing. This can significantly decrease the size of the resulting snapshot because empty blocks are omitted. If there exists a previous snapshot for the disk, the agent receives a stream of block hashes. A single worker thread reads blocks from the disk and compares their hashes against the block hashes retrieved from the server. If the hashes do not match, the block is passed into a send queue to be egressed to the server.","title":"Create Snapshot"},{"location":"specification/plugins/snapshot.html#apply-snapshot","text":"If there exists a previous snapshot for the disk, the agent initiates a stream of block hashes. A single worker thread reads blocks from the disk and passes their hashes into a send queue to be egressed to the server. Simultaneously, the agent receives a stream of block data which are placed into a write queue to be written to the device.","title":"Apply Snapshot"},{"location":"specification/plugins/snapshot.html#snapshot-messages","text":"","title":"Snapshot Messages"},{"location":"specification/plugins/snapshot.html#ev_snapshotdatablock","text":"// Contains snapshot data. // // Source: Server, Agent // Destination: Server, Agent Field Type Requirements Description offset int64 The block's offset data bytes The block's contents compressed with zlib","title":"EV_SnapshotDataBlock"},{"location":"specification/plugins/snapshot.html#ev_snapshothashblock","text":"// Contains a list of contiguous snapshot hashes. // // Source: Server, Agent // Destination: Server, Agent Field Type Requirements Description offset int64 The offset of the block that the first hash corresponds hash repeated bytes A list of block hashes","title":"EV_SnapshotHashBlock"},{"location":"specification/plugins/snapshot.html#permissions-list","text":"Permission Description agent.snapshot.create Rights create new snapshots of agent disks agent.snapshot.apply Rights apply existing snapshots to agent disks server.snapshot.list Rights to list existing snapshots stored by the server","title":"Permissions list"},{"location":"specification/plugins/snapshot.html#configuration","text":"Property Default Description s7s.snapshot.storage.provider filesystem The storage provider to use s7s.snapshot.storage.filesystem.path The filesystem path","title":"Configuration"},{"location":"tutorials/getting_started.html","text":"Getting Started If you just want to demo Sandpolis, try connecting to the official demo server ( demo.sandpolis.com ) with the desktop client. You'll be able to look around at simulated systems, but won't be able to add your own agents. Otherwise, if you want to run your own Sandpolis network, the first thing you need is a private server instance. Deploying the Server There are several different ways to install the server. The universal installer is a user-friendly method that will work on just about every system, but a specialized distribution package or Docker container is the most convenient option for keeping the server updated. With Docker The server can be run as a Docker container with the following command: docker run \\ --name sandpolis-server \\ --restart unless-stopped \\ -p 8678:8678 \\ sandpolis/server:latest Note If your instance isn't starting on boot, ensure the Docker daemon is configured to start automatically: sh sudo systemctl enable docker The default admin password will be printed in the container's log which can be viewed with the following command: docker logs sandpolis-server With a distribution package Pacman (Arch Linux) Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service With the universal installer GUI Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\". Installing a Client There are several official client applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs best. Sandpolis Desktop Client Sandpolis for iOS The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater. Installing the Agent Once you're logged into a server, the last thing to do is install an agent. As with clients, there are several choices that are suitable in different environments. Standard Agent The standard agent has the most features and highest performance impact. It runs on the JVM and is multi-platform. Native Agent The native agent has fewer features and a much smaller resource requirement. It's platform-specific. Minimal Agent The minimal agent has no external dependencies and is designed to run on highly resource constrained platforms. Deployment Types In addition to different agent types, there are a few different ways each can be deployed. Standard Deploy The typical way to deploy an agent is by installing it with your platform's package manager and configuring it on first run. When prompted, enter the server's address, an optional password, and an optional time-based alphanumeric token provided in the client's user interface. Note This deployment method is not available for the minimal agent. Container Resident All agent types can also be deployed as Docker containers. For example: docker run \\ --name sandpolis-agent \\ --restart unless-stopped \\ -v /:/host:ro \\ sandpolis/agent This mounts the host's filesystem into the container with read-only permissions which is the most common usage. SSH Deploy The SSH deploy is most convenient if your systems are already running SSH servers. After entering an IP address, username, and password (or keyfile), an agent will be generated and transferred via SSH. Note This deployment method supports all agent types and compatible platforms. Manual Deploy An installer executable can be generated and manually installed on systems. This approach has the disadvantage that installers are not cryptographically signed and it requires the most manual intervention. Note This deployment method supports all agent types and compatible platforms.","title":"Getting Started"},{"location":"tutorials/getting_started.html#getting-started","text":"If you just want to demo Sandpolis, try connecting to the official demo server ( demo.sandpolis.com ) with the desktop client. You'll be able to look around at simulated systems, but won't be able to add your own agents. Otherwise, if you want to run your own Sandpolis network, the first thing you need is a private server instance.","title":"Getting Started"},{"location":"tutorials/getting_started.html#deploying-the-server","text":"There are several different ways to install the server. The universal installer is a user-friendly method that will work on just about every system, but a specialized distribution package or Docker container is the most convenient option for keeping the server updated.","title":"Deploying the Server"},{"location":"tutorials/getting_started.html#with-docker","text":"The server can be run as a Docker container with the following command: docker run \\ --name sandpolis-server \\ --restart unless-stopped \\ -p 8678:8678 \\ sandpolis/server:latest Note If your instance isn't starting on boot, ensure the Docker daemon is configured to start automatically: sh sudo systemctl enable docker The default admin password will be printed in the container's log which can be viewed with the following command: docker logs sandpolis-server","title":"With Docker"},{"location":"tutorials/getting_started.html#with-a-distribution-package","text":"","title":"With a distribution package"},{"location":"tutorials/getting_started.html#pacman-arch-linux","text":"Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service","title":"Pacman (Arch Linux)"},{"location":"tutorials/getting_started.html#with-the-universal-installer-gui","text":"Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\".","title":"With the universal installer GUI"},{"location":"tutorials/getting_started.html#installing-a-client","text":"There are several official client applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs best.","title":"Installing a Client"},{"location":"tutorials/getting_started.html#sandpolis-desktop-client","text":"","title":"Sandpolis Desktop Client"},{"location":"tutorials/getting_started.html#sandpolis-for-ios","text":"The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater.","title":"Sandpolis for iOS"},{"location":"tutorials/getting_started.html#installing-the-agent","text":"Once you're logged into a server, the last thing to do is install an agent. As with clients, there are several choices that are suitable in different environments.","title":"Installing the Agent"},{"location":"tutorials/getting_started.html#standard-agent","text":"The standard agent has the most features and highest performance impact. It runs on the JVM and is multi-platform.","title":"Standard Agent"},{"location":"tutorials/getting_started.html#native-agent","text":"The native agent has fewer features and a much smaller resource requirement. It's platform-specific.","title":"Native Agent"},{"location":"tutorials/getting_started.html#minimal-agent","text":"The minimal agent has no external dependencies and is designed to run on highly resource constrained platforms.","title":"Minimal Agent"},{"location":"tutorials/getting_started.html#deployment-types","text":"In addition to different agent types, there are a few different ways each can be deployed.","title":"Deployment Types"},{"location":"tutorials/getting_started.html#standard-deploy","text":"The typical way to deploy an agent is by installing it with your platform's package manager and configuring it on first run. When prompted, enter the server's address, an optional password, and an optional time-based alphanumeric token provided in the client's user interface. Note This deployment method is not available for the minimal agent.","title":"Standard Deploy"},{"location":"tutorials/getting_started.html#container-resident","text":"All agent types can also be deployed as Docker containers. For example: docker run \\ --name sandpolis-agent \\ --restart unless-stopped \\ -v /:/host:ro \\ sandpolis/agent This mounts the host's filesystem into the container with read-only permissions which is the most common usage.","title":"Container Resident"},{"location":"tutorials/getting_started.html#ssh-deploy","text":"The SSH deploy is most convenient if your systems are already running SSH servers. After entering an IP address, username, and password (or keyfile), an agent will be generated and transferred via SSH. Note This deployment method supports all agent types and compatible platforms.","title":"SSH Deploy"},{"location":"tutorials/getting_started.html#manual-deploy","text":"An installer executable can be generated and manually installed on systems. This approach has the disadvantage that installers are not cryptographically signed and it requires the most manual intervention. Note This deployment method supports all agent types and compatible platforms.","title":"Manual Deploy"},{"location":"tutorials/client/gui.html","text":"Sandpolis Desktop Interface The desktop application is a fully-featured GUI that runs on Windows, Linux, and macOS.","title":"Using the desktop client"},{"location":"tutorials/client/gui.html#sandpolis-desktop-interface","text":"The desktop application is a fully-featured GUI that runs on Windows, Linux, and macOS.","title":"Sandpolis Desktop Interface"},{"location":"tutorials/client/ios.html","text":"","title":"Ios"},{"location":"tutorials/client/terminal.html","text":"Terminal Interface Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use. As an added benefit, you'll look like a l33t h@ck3r when using it. Installation Starting a Listener Generating an Installer Address Port Timeout Path","title":"Using the terminal client"},{"location":"tutorials/client/terminal.html#terminal-interface","text":"Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use. As an added benefit, you'll look like a l33t h@ck3r when using it.","title":"Terminal Interface"},{"location":"tutorials/client/terminal.html#installation","text":"","title":"Installation"},{"location":"tutorials/client/terminal.html#starting-a-listener","text":"","title":"Starting a Listener"},{"location":"tutorials/client/terminal.html#generating-an-installer","text":"","title":"Generating an Installer"},{"location":"tutorials/client/terminal.html#address","text":"","title":"Address"},{"location":"tutorials/client/terminal.html#port","text":"","title":"Port"},{"location":"tutorials/client/terminal.html#timeout","text":"","title":"Timeout"},{"location":"tutorials/client/terminal.html#path","text":"","title":"Path"}]}